---
params:
  subtitle: ""
  title: ""
  authors: ""
title: '`r params$title`'
subtitle: '`r params$subtitle`'
author: '`r params$authors`'
date: 'Last run at: `r Sys.time()`'
output:
  bookdown::html_document2:
    fig_caption: yes
    code_folding: hide
    number_sections: yes
    toc: yes
    toc_depth: 2
    toc_float: TRUE
  bookdown::pdf_document2:
    fig_caption: yes
    number_sections: yes
  bookdown::word_document2:
    fig_caption: yes
    number_sections: yes
    toc: yes
    toc_depth: 2
    fig_width: 5
always_allow_html: yes
bibliography: '`r paste0(here::here(), "/bibliography.bib")`'
---

```{r knitrSetup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE) # by default turn off code echo
```


```{r codeSetup, include=FALSE}
# Set start time ----
startTime <- proc.time()
# Local parameters ----
b2Kb <- 1024 #http://whatsabyte.com/P1/byteconverter.htm
b2Mb <- 1048576
plotLoc <- paste0(gcParams$repoLoc, "/docs/plots/") # where to put the plots

library(gridCarbon)
# Packages used in the report ----
rmdLibs <- c("ggplot2", # plots
          "kableExtra", # fancy tables
          "lubridate"
          )
gridCarbon::loadLibraries(rmdLibs)

# Local parameters ----
localParams$lockDownStartDate <- as.Date("2020-03-25")
localParams$lockDownStartDateTime <- lubridate::as_datetime("2020-03-25 23:59:00")
localParams$lockDownEndDate <- lubridate::today()
localParams$lockDownEndDateTime <- lubridate::now()

localParams$recentCutDate <- as.Date("2020-03-01")

localParams$comparePlotCutDate <- as.Date("2020-02-01")

localParams$gamCap <- "Trend line = Generalized additive model (gam) with integrated smoothness estimation"
localParams$lockdownCap <- "\nColoured rectangle = NZ covid lockdown to date"
localParams$weekendCap <- "\nShaded rectangle = weekends"
localParams$noThresh <- "\nNo specified WHO threshold"

localParams$myAlpha <- 0.1
localParams$vLineAlpha <- 0.4
localParams$vLineCol <- "red" # http://www.cookbook-r.com/Graphs/Colors_(ggplot2)/#a-colorblind-friendly-palette
localParams$myTextSize <- 4

# Local functions ----
addLockdownDate <- function(p){
  # assumes p has x = obsDate
  p <- p + annotate("rect", xmin = localParams$lockDownStartDate,
             xmax = localParams$lockDownEndDate, 
             ymin = yMin, ymax = yMax, 
             alpha = localParams$myAlpha, 
             fill = localParams$vLineCol, 
             colour = localParams$vLineCol)
  return(p)
}
addLockdownDateTime <- function(p){
  # assumes p has x = obsDateTime
  p <- p + annotate("rect", xmin = localParams$lockDownStartDateTime,
             xmax = localParams$lockDownEndDateTime, 
             ymin = yMin, ymax = yMax, 
             alpha = localParams$myAlpha, 
             fill = localParams$vLineCol, 
             colour = localParams$vLineCol) 
    
  return(p)
}

# only makes sense to use these for x axis covering March onwards
localParams$weAlpha <- 0.3
localParams$weFill <- "grey50"
addWeekendsDate <- function(p){
  p <- p + annotate("rect", xmin = as.Date("2020-03-07"),
                    xmax = as.Date("2020-03-08"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = as.Date("2020-03-14"),
                    xmax = as.Date("2020-03-15"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = as.Date("2020-03-21"),
                    xmax = as.Date("2020-03-22"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = as.Date("2020-03-28"),
                    xmax = as.Date("2020-03-29"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = as.Date("2020-04-04"),
                    xmax = as.Date("2020-04-05"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = as.Date("2020-04-10"),
                    xmax = as.Date("2020-04-13"), # Easter
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  return(p)
}

addWeekendsDateTime <- function(p){
   p <- p + annotate("rect", xmin = lubridate::as_datetime("2020-03-07 00:00:00"),
                    xmax = lubridate::as_datetime("2020-03-08 23:59:59"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = lubridate::as_datetime("2020-03-14 00:00:00"),
                    xmax = lubridate::as_datetime("2020-03-15 23:59:59"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = lubridate::as_datetime("2020-03-21 00:00:00"),
                    xmax = lubridate::as_datetime("2020-03-22 23:59:59"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = lubridate::as_datetime("2020-03-28 00:00:00"),
                    xmax = lubridate::as_datetime("2020-03-29 23:59:59"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  p <- p + annotate("rect", xmin = lubridate::as_datetime("2020-04-04 00:00:00"),
                    xmax = lubridate::as_datetime("2020-04-05 23:59:59"),
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill) 
  p <- p + annotate("rect", xmin = as_datetime("2020-04-10 00:00:00"),
                    xmax = as_datetime("2020-04-13 23:59:59"), # Easter
                    ymin = yMin, ymax = yMax,
                    alpha = localParams$weAlpha, fill = localParams$weFill)
  return(p)
}
```

\newpage

# About

## Citation

```{r citation, child=gcParams$citation}
```

## Report circulation

 * Public – this report is intended for publication following EECA approval.

## Code

All code used to create this report is available from:

 * https://github.com/CfSOtago/gridCarbon

## License {#license}

```{r ccby license, child=gcParams$licenseCCBY}
```

## History

```{r history, child=gcParams$history}
```
 * this [report's edit history](https://github.com/CfSOtago/gridCarbon/commits/master/dataAnalysis/)
 
## Support

```{r generic support, child=gcParams$support}
```
 * The European Union via [SPATIALEC](http://www.energy.soton.ac.uk/tag/spatialec/), a Marie Skłodowska-Curie [Global Fellowship](https://ec.europa.eu/research/mariecurieactions/actions/individual-fellowships_en) based at the University of Otago’s [Centre for Sustainability](http://www.otago.ac.nz/centre-sustainability/staff/otago673896.html) (2017-2019) & the University of Southampton’s [Sustainable Energy Research Group](http://www.otago.ac.nz/centre-sustainability/staff/otago673896.html) (2019-2020) (Anderson);
 * The Uniersity of Otago via a Centre for Sustainability Summer Scholarship (Lotte) and PhD Studentship (Dortans)
 
\newpage

# Introduction

Building on [@khan_analysis_2018], we are interested in GHG emissions from the NZ electricity generation over time. We are especially interested in how this might change during the NZ covid-19 lockdown period (`r localParams$lockDownStart` to `r localParams$lockDownEnd`).

We use two different GHG emissions indicators:

 * % of total generation in a halfhour which was 'low emissions' where this is defined as wind + solar + hydro
 * Calculated CO2e emissions per half hour (not yet implemented)

# Data

## Wholesale generation data

Essentially 'grid' generation from major power stations of various kinds. Data downloaded from `https://www.emi.ea.govt.nz/Wholesale/Datasets/Generation/Generation_MD/` and pre-processed.

```{r testGrid}
h <- head(allGridDT)

kableExtra::kable(h, caption = "Grid gen data (first 6 rows)") %>%
  kable_styling()
```

## Embedded generation data

Essentially 'non-grid' generation from solar photovoltaic and small scale wind which is 'embedded' - i.e. non-grid connected as it is connected 'downstream' of the grid exit points (GXP). Data downloaded from `https://www.emi.ea.govt.nz/Wholesale/Datasets/Metered_data/Embedded_generation` and pre-processed.

```{r headEmbedded}
h <- head(allEmbeddedDT)

kableExtra::kable(h, caption = "Embedded gen data (first 6 rows)") %>%
  kable_styling()
```


```{r testEmbedded}
allEmbeddedDT[, year := lubridate::year(rDate)]
st <- allEmbeddedDT[, .(sumkWh = sum(kWh, na.rm = TRUE),
                        nObs = .N), keyby = .(Flow_Direction, year)]

rt <- data.table::dcast(st, year ~ Flow_Direction,  value.var = c("sumkWh", "nObs"))

kableExtra::kable(rt, caption = "Mean kWh by flow direction") %>%
  kable_styling()
```

Not entirely sure what these codes mean yet. Limited [guidance](https://forum.emi.ea.govt.nz/thread/grid-export-and-embedded-generation-data) available? TBC

> For now embedded generation data is _not_ included in the following analysis.

# Analysis

In this section we analyse the current developments in electricity generation during the Covid-19 level four alert. The level four alert came into effect on March 25 2020 at 11.59pm as part of the fight agianst the novel Covid-19 virus. The minimum lockdown period is four weeks, ending on April 23. This period has wide-spread implications across New Zealand's economy and electriicty consumption, amongst other effects such as everyday life in general.

All non-essential busineeses are closed and staff is asked to work from home. This analysis aims to provide insights on developments in electriicty generation. Essential research questions company this research:

* To what extent has electricty generation shown deviation of 'normal' generation patterns during the level four alert?

* Has the composition of fuel sources supplying electriicty demand in New Zealand changed during the level four alert?

* Has the level four alert impacted greenhouse-gas emissions associated with electriicty generation?

```{r lockdownMethodology, eval=FALSE}

# 1. Select relevant years/months
  # -> What do we want to find out? 
   # Reduction in generation (this requires ex ante/post ante data)
   # Changes in the feed-in of embedded generation
   # Changes in GhG emissions

# 2. Aggregate data by fuel and time
# 3. Link GhG emissions to generation data
# 4. Output of tables/plots embedded in text

```

```{r lockdown1SelectData, include=FALSE}

#Selects Jan and Feb of 2020, 2019, 2018 as we do not have March data yet
selectDT <- allGridDT[month >= 1 & 
                      month <= 4 &
                      year == 2020 |
                        
                      month >= 1 & 
                      month <= 4 &
                      year == 2019 |
                        
                      month >= 1 & 
                      month <= 4 &
                      year == 2018]

#Building means by Fuel_Code, rDateTime, Time_Period, rMonth
shortDT <- selectDT[, . (meankWh = mean(kWh),
                         sumkWh = sum(kWh),
                        nObs = .N), # number of obs - will show you how rare coal is :-)
                    keyby= .(Fuel_Code, rDateTime, Time_Period, rMonth, year)]
#This won't build means by month - it will build them by rDateTime as rMonth is constant for each rDateTime


#This shows us how many obs there are for each Fuel_Code. There might be an easier way to do it?
plotDT <- shortDT[year==2020]
x2 <- by(plotDT$nObs, plotDT$Fuel_Code, sum)
do.call(rbind,as.list(x2))# Clearly hydro dominates
```


```{r nobstable}
#Put this into a table for visualisation
kableExtra::kable(head(x2), col.names = "nObs", caption = "Number of observations by fuel") %>%
                    kable_styling()
```
We extracted electricity generation data from /INSERT DATES/. Table \@ref(tab:nobstable) shows the number of observations for each fuel type for the aforementioned dates. It becomes clear that Hydro was the most used fuel type, followed by Geothermal, Wind, Gas, Coal, and Diesel. 

```{r lockdowncalc}

#Let us try to avoid confusion with kWh and convert it to power MW....
shortDT <- shortDT[, meanMW := (meankWh*2)/1000]
shortDT <- shortDT[, sumMW := (sumkWh*2)/1000]




kableExtra::kable(head(shortDT), caption = "Example summary data") %>%
                    kable_styling()
```
Table \@ref(tab:lockdowncalc) shows exemplary data of our data extraction. In addition, Figure \@ref(fig:plotgeneration1) pictures total generation (this is the sum for each fuel type for all generatinfg plants and all trading periods). Hydro had the highest power output in January and February. Geothermnal was used for base load and an increase in Gas output is viible for the second half of February. Wind intermittently generated while Coal was occasionally integrated. Wood and Diesel did not contribute much in January and February.


```{r plotgeneration1, fig.cap= "Total generation by fuel"}

#Changing order in plot

shortDT$Fuel_Code <- factor(shortDT$Fuel_Code, levels = c("Hydro","Geo",
                                                    "Gas", "Wind", "Coal", "Wood", "Diesel"))

plotDT <- shortDT[year==2020]

legend_title <- "Type of Fuel"
myPlotSum <- ggplot2::ggplot(plotDT, aes(x= rDateTime)) +
  geom_line(aes(y = sumMW, colour = Fuel_Code))+
  scale_color_manual(legend_title, values = c('Hydro'='blue','Coal'='grey', 'Wind'='green', 'Wood'='brown', 'Diesel'='yellow', 'Gas'='purple', 'Geo'='red'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Time', y='Power (MW)') 
myPlotSum





```
Figure \@ref(fig:totalgen) shows total generation data for January and February 2020. In addition, a linear model and its error distribution is highlighted in blue. In summary, variation in electriicty generation was particularly apparent in February.

```{r totalgen, fig.cap= "Total generation data for January and February", warning=FALSE, message=FALSE}

# Here we attempt to compare total generation over time. Monthly/weekly granularity
# Challenge: Match Monday with Monday and have the same number of days for comparison

#We might need to dcast now...

recastDT <- dcast(shortDT,
           rDateTime + Time_Period + rMonth + year  ~ Fuel_Code, 
           fun = mean, # won't do anything as we should just have 1 value?
           value.var = "sumMW")

# Adding a weekday column
recastDT <- recastDT[, weekdays:= wday(rDateTime, label = TRUE)]
#Adding date column
recastDT[, date := lubridate::as_date(rDateTime)]



recastDT <- recastDT[, totalMW := Coal+Diesel+Gas+Geo+Hydro+Wind+Wood, keyby =.(rDateTime)]


plotDT <-recastDT[year==2020]

legend_title <- "Month"
myPlotTot <- ggplot2::ggplot(plotDT, 
                             aes(x= rDateTime,
                                 y = totalMW, 
                                 colour = rMonth)) +
  geom_line() +
  geom_smooth()+
  scale_color_manual(legend_title, values = c('Jan'='#48C9B0','Feb'='#F4D03F'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Date', y='Power (MW)', caption = "Smoothed fit line via gam") 
  #facet_grid(rMonth ~ .)
  #stat_smooth(method = "gam", )
myPlotTot


#Another plot version
#legend_title <- "Month"
#myPlotTot <- ggplot2::ggplot(totalgenDT, aes(x= rDateTime)) +
#  geom_area(aes(y= totalMW, color = rMonth, fill = rMonth), 
#            alpha = 0.5, position = position_dodge(0.8)) +
#  scale_color_manual(values = c("#00AFBB", "#E7B800")) +
#  scale_fill_manual(values = c("#00AFBB", "#E7B800"))+
#  #scale_color_manual(legend_title, values = c('Jan'='blue','Feb'='red'))+
#  theme(axis.text.x = element_text(colour = "black"),
#        axis.text.y = element_text(colour ="black"))+
#  labs(x='Time', y='Power (MW)') +
#  #facet_grid(rMonth ~ .)
#  stat_smooth(aes(y=totalMW, method = "gam"))
#myPlotTot

```

Figure \@ref(fig:fourmonthsplot) shows total generation for the first four months of 2020. A red box indicates the alert level four period.

```{r fourmonths}

plotDT <- recastDT[year==2020]

```

```{r fourmonthsplot, fig.cap="For months of total generation for 2020"}

#This shows us the selected weeks for January and February
legend_title <- "Month"
myPlotTot <- ggplot2::ggplot(plotDT, aes(x= rDateTime )) +
  geom_line(aes(y = totalMW, colour = rMonth))+
  geom_smooth(aes(y=totalMW, clour=rMonth))+
  scale_color_manual(legend_title, values = c('Jan'='#A9DFBF','Feb'='#FAD7A0', 'Mar'='#AED6F1', 'Apr' ='#F5B7B1'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Date', y='Power (MW)', caption = "Smoothed fit line via gam") 
  #facet_grid(rMonth ~ .)

yMax <- max(plotDT$totalMW)
yMin <- min(plotDT$totalMW)
addLockdownDateTime(myPlotTot) # adds annotations, needs yMax & yMin to get the box right
```

```{r annualcomparision}

#Now we woild like to compare the first four months of 2020 with the previous years. Challenge lining up Monday with Monday etc. 

                            #2020
plotDT <- recastDT[date >= "2020-01-08"&
                   date <= "2020-01-28"|
                     
                   date >= "2020-02-05"&
                   date <= "2020-02-25"|
                     
                  # date >= "2020-03-10"&
                  # date <= "2020-03-30"|
                     
                  # date >= "2020-04-01"&
                  # date <= "2020-04-21"|
                     
                          #2019     
                   date >= "2019-01-09"&
                   date <= "2019-01-29"|
                     
                   date >= "2019-02-06"&
                   date <= "2019-02-26"|
                     
                  # date >= "2019-03-05"&
                  # date <= "2019-03-25"|
                     
                  # date >= "2019-04-03"&
                  # date <= "2019-04-23"| 
                     
                          #2018
                   date >= "2018-01-10"&
                   date <= "2018-01-30"|
                     
                   date >= "2018-02-07"&
                   date <= "2018-02-27"]
                     
                  # date >= "2018-03-06"&
                  # date <= "2018-03-26"|
                     
                  # date >= "2018-04-04"&
                  # date <= "2018-04-24"]

# Remember that we do not have March and April data for 2020 yet so we have to leave these dates out for now 

# Applying the same overlaying method on three years now...

date <- plotDT[year==2020]

data1 <- data.table(`2020`=numeric())
data1 <-data1[, .(`2020` = ifelse(plotDT$year == "2020" , plotDT$totalMW, NA ))]
data1 <-data1[!is.na(data1$`2020`)]

data2 <- data.table(`2019`=numeric())
data2 <-data2[, .(`2019` = ifelse(plotDT$year == "2019" , plotDT$totalMW, NA ))]
data2 <-data2[!is.na(data2$`2019`)]

data3 <- data.table(`2018`=numeric())
data3 <-data3[, .(`2018` = ifelse(plotDT$year == "2018" , plotDT$totalMW, NA ))]
data3 <-data3[!is.na(data3$`2018`)]

data1 <- data1[, `2019` := data2$`2019`]
data1 <- data1[, `2018` := data3$`2018`]
data1 <- data1[, ID := .I]
data1 <- data1[, date := date$date]

```

```{r annualcomparisonplot, fig.cap="Three years with each 20 days of data for January and February so far"}

#This shows us the selected weeks for January and February
legend_title <- "Year"
myPlotTot <- ggplot2::ggplot(data1, aes(x= date )) +
  #geom_line(aes(y = `2020`, colour = 'purple'))+
  geom_smooth(aes(y=`2020`, colour = "2020"))+
  geom_smooth(aes(y=`2019`, colour = "2019"))+
  geom_smooth(aes(y=`2018`, colour = "2018"))+
  scale_color_manual(legend_title, values = c(`2020`='#3498DB',`2019`='#229954', `2018`='#CA6F1E'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Day and Month', y='Power (MW)', caption = "Smoothed fit line via gam")+
  scale_x_date(date_breaks = '1 week',
               minor_breaks = 'day',
                 #date_labels = '%b %a')+
               date_labels  ='%b %n %a')+
  scale_y_continuous( limits = c(3014,5866))
  #facet_grid(rMonth ~ .)

yMax <- max(plotDT$totalMW)
yMin <- min(plotDT$totalMW)
#addLockdownDateTime(myPlotTot) # adds annotations, needs yMax & yMin to get the box right

myPlotTot

# date_labels = '%b %d\n%a')+

```

```{r threeweektotal}
#Perhaps it is time to select three weeks and compare them properly?
#06.01.2010-26.01.2020 and 03.02.2020-23.02.2020


plotDT <- recastDT[date >="2020-01-06" & 
                            date <= "2020-01-26" |
                            date >= "2020-02-03" &
                            date <= "2020-02-23"]

# I have to somehow overlay the two variables in rMonth
# yes. It's not easy, about the only thing you can do is use the day of the month
# and then shift them to get weekdays/weekends to line up :-)

```


This is conducted in Figure \@ref(fig:overlayedtotalplot). This view of overlaying data requires us to use the idividual time stamps on the x-axis instead of dates. We can identify individual days with two peaks in each day. The first day represents a Monday etc. Electricity generation on the weekends was lower than during the week and January showed a alightly higher overall generation. 

```{r overlayedtotalplot, fig.cap= "Overlayed three week data for January and February"}
# ha ha. Yes this works quite well

#There must be a way to overlay this data...
data1 <- data.table(Jan=numeric())
data1 <-data1[, .(Jan = ifelse(plotDT$rMonth == "Jan" & plotDT$year == "2020" , plotDT$totalMW, NA ))]
data1 <-data1[!is.na(data1$Jan)]


data2 <-data.table(Feb=numeric())
data2 <-data2[, .(Feb = ifelse(plotDT$rMonth == "Feb" & plotDT$year=="2020", plotDT$totalMW, NA ))]
data2 <-data2[!is.na(data2$Feb)]


data1 <- data1[, Feb := data2$Feb]
data1 <- data1[, ID := .I]

#We lost our sense of time here but we can still see each individual day. Weekends have lower generation. The time stamp number increases over time. Every 15 minutes one stamo is added.
legend_title <- "Month"
myPlotTot <- ggplot2::ggplot(data1, aes(x= ID)) +
geom_line(aes(y = Jan, colour = "Jan"), size = .4)+
geom_line(aes(y = Feb, colour = "Feb"), size = .4)+
scale_color_manual(legend_title, labels = c("Jan",
                                              "Feb"), values = c("#48C9B0",
                                                                  "#F4D03F")) +
theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  #scale_fill_discrete(name = "Month", labels = c("Jan", "Feb"))
  labs(x='Time stamp', y='Power (MW)') 
  #facet_grid(rMonth ~ .)
myPlotTot


```

```{r annualcomparison}

# Here our aim is to create a plot that shows the first three months of 2018, 2019, 2020 to see if there is significant change

plotDT <- recastDT[date >="2020-01-06" & 
                            date <= "2020-01-26" |
                            date >= "2020-02-03" &
                            date <= "2020-02-23"|
                     
                   date >="2020-01-06" & 
                            date <= "2020-01-26" |
                            date >= "2020-02-03" &
                            date <= "2020-02-23"]







```

```{r whatisnext}

#Next we want to find out what happened on a time_period average for three weeks. Furthermore we would like to find out how the generation compostion by fuel source might have changed in the two months. Some fun for tomorrow :)

# we need to compare Feb/March 2020 with the mean for Feb/March in previous years, also allowing for different temperatures etc?

```

```{r test, eval=FALSE}



#Test
myPlotMean <- ggplot2::ggplot(shortDT, aes(x= rDateTime)) +
  geom_line(aes(y = meankWh, colour = Fuel_Code))+
  scale_color_manual(values = c('Hydro'='blue','Coal'='grey', 'Wind'='green', 'Wood'='brown', 'Diesel'='yellow', 'Gas'='purple', 'Geo'='red'))
#myPlotMean



#Changing order in plot

shortDT$Fuel_Code <- factor(shortDT$Fuel_Code, levels = c("Hydro","Geo",
                                                    "Gas", "Wind", "Coal", "Wood", "Diesel"))

legend_title <- "Type of Fuel"
myPlotSum <- ggplot2::ggplot(shortDT, aes(x= rDateTime)) +
  geom_line(aes(y = sumMW, colour = Fuel_Code))+
  scale_color_manual(legend_title, values = c('Hydro'='blue','Coal'='grey', 'Wind'='green', 'Wood'='brown', 'Diesel'='yellow', 'Gas'='purple', 'Geo'='red'))+
  theme(axis.text.x = element_text(colour = "black"),
        axis.text.y = element_text(colour ="black"))+
  labs(x='Time', y='Power (MW)') 
myPlotSum







# give it a new name as we've dcast it
recastDT <- dcast(shortDT,
           rDateTime + Time_Period + rMonth  ~ Fuel_Code, 
           fun = mean, # won't do anything as we should just have 1 value?
           value.var = "meankWh")


#Test2
legend_title <- "Type of Fuel"
myPlot <- ggplot2::ggplot(recastDT, aes(x= rDateTime)) +
  geom_line(aes(y = Coal, colour = "Coal"))+
  geom_line(aes(y = Diesel, colour = "Diesel"))+
  geom_line(aes(y=Hydro, colour = "Hydro"))+
  scale_color_manual(legend_title, labels = c("Coal",
                                              "Diesel",
                                              "Hydro"), values = c("grey",
                                                                  "black",
                                                                  "blue")) 
  myPlot
  

  #Still does  not look right. Even when I sum Coal and Hydro kWh, Coal is much more which does not make sense. Perhaps the labeling in allGridDT is wrong???

# BA: No the labels are right, the problem is the mean is only calculated over half-hours which have generation. So all the half-hours where coal = 0 are not included. In other words what you have found is that when coal is used, it produces a lot of MWh. But it is not used very often. So the 'mean in use' is high but you will find the sum of half hourly kWh is low. If you look at the nObs column I have introduced to shortDT you can see this. 
  
# Do not sum the mean kWh - the mean will have captured the 'high' coal output. In general one should never sum a mean unless you know how many observations have contributed to each mean...


```

```{r usefulCode, eval=FALSE}
#\@ref(fig:wattageContributionPeak1Plot)
#fig.cap="Percentage contribution to peak demand (17:00-21:00) in 2015"

#\@ref(tab:averageAtPeak)


```

# Annexes

## Wholesale generation data ('grid')

```{r skimGrid}
skimr::skim(allGridDT)
```

## Embedded generation data ('nongrid')

```{r skimNonGrid}
skimr::skim(allEmbeddedDT)
```

## Conversion factors


# Runtime

```{r check runtime, include=FALSE}
t <- proc.time() - startTime
elapsed <- t[[3]]
```

Analysis completed in `r round(elapsed,2)` seconds ( `r round(elapsed/60,2)` minutes) using [knitr](https://cran.r-project.org/package=knitr) in [RStudio](http://www.rstudio.com) with `r R.version.string` running on `r R.version$platform`.

# R environment

## R packages used

 * base R [@baseR]
 * bookdown [@bookdown]
 * data.table [@data.table]
 * ggplot2 [@ggplot2]
 * kableExtra [@kableExtra]
 * knitr [@knitr]
 * lubridate [@lubridate]
 * rmarkdown [@rmarkdown]

## Session info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

# References
